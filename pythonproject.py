# -*- coding: utf-8 -*-
"""pythonproject.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qM8sS8irgvxr-U_w83q629GDjU4naxi-

#**Heart Disease Prediction Using Logistic Regression**

**Step 1:** Importing libraries
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
# %matplotlib inline
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score
from sklearn.metrics import confusion_matrix
from sklearn.model_selection import cross_val_score
from sklearn.metrics import roc_auc_score

"""**Step 2:** Mounting drive into the colab notebook"""

from google.colab import drive
drive.mount('/content/drive')

"""**Step 3:** Reading data from the drive"""

heart=pd.read_csv('/content/drive/MyDrive/heart.csv')
heart

"""##Data Preprocessing

**Step 4:** Analysing the dataset.

1. shape of the graph
2. columns of the graphs.
3. checking null values
4. checking the presence of duplicates
5. checking mean,min,etc. using describe function.
"""

#shape of the graph
heart.shape

#columns of the graphs.
heart.columns

heart.isnull().sum()

#checking null values
heart.info()

heart.describe().T

"""**Step 5:** Dividing numerical and categorial data
1. Here the value which are unique in the categorical data are atmost 4.
2. So if we calculate the unique value count and get more than 6(let's consider) then we can consider it as numerical data else categorical.
"""

col = list(heart.columns)
categorical_features = []
numerical_features = []
for i in col:
    if len(heart[i].unique()) > 6:
        numerical_features.append(i)
    else:
        categorical_features.append(i)

print('Categorical Features :',*categorical_features)
print('Numerical Features :',*numerical_features)

"""**Step 6:** creating a deep copy of our data set and converting all the columns to numerical values"""

from sklearn.preprocessing import LabelEncoder
le = LabelEncoder()
deep_copy_heart = heart.copy(deep = True)

deep_copy_heart['Sex'] = le.fit_transform(deep_copy_heart['Sex'])
deep_copy_heart['ChestPainType'] = le.fit_transform(deep_copy_heart['ChestPainType'])
deep_copy_heart['RestingECG'] = le.fit_transform(deep_copy_heart['RestingECG'])
deep_copy_heart['ExerciseAngina'] = le.fit_transform(deep_copy_heart['ExerciseAngina'])
deep_copy_heart['ST_Slope'] = le.fit_transform(deep_copy_heart['ST_Slope'])

deep_copy_heart

"""##Data Visualization

**Step 7:** visualizing the count of the total no. of heart diseased people along with people without heart disease
"""

heart_disease_counts = heart['HeartDisease'].value_counts()

# Define the colors. '1' for heart disease is red, '0' for healthy heart is any other color (e.g., green)
colors = ['red' if label == 1 else 'green' for label in heart_disease_counts.index]

fig, axs = plt.subplots(1, 2, figsize=(12, 6))  # 1 row, 2 columns

# Create a pie chart
axs[0].pie(heart_disease_counts, labels = heart_disease_counts.index, colors = colors, autopct='%1.1f%%')
axs[0].set_title('Heart Disease Distribution')

# Create a bar graph
axs[1].bar(heart_disease_counts.index, heart_disease_counts, color = colors)
axs[1].set_xlabel('Heart Disease')
axs[1].set_ylabel('Count')
axs[1].set_title('Heart Disease Count')
axs[1].set_xticks(heart_disease_counts.index)

plt.tight_layout()
plt.show()

"""**Step 8**:** Aanalysing the data by plotting graph for different scenario."""

data=heart

fig, ax = plt.subplots(nrows = 3, ncols = 2, figsize = (10, 15))
for i in range(len(categorical_features) - 1):
    ax = plt.subplot(3, 2, i+1)
    sns.countplot(x=categorical_features[i], data=data, hue="HeartDisease", palette=colors, edgecolor='black', ax=ax)
    for rect in ax.patches:
        ax.text(rect.get_x() + rect.get_width() / 2, rect.get_height() + 2, rect.get_height(), horizontalalignment='center', fontsize = 11)
    title = categorical_features[i] + ' vs HeartDisease'
    plt.legend(['No Heart Disease','Heart Disease'])
    plt.title(title)
plt.tight_layout()
plt.show()

"""Number Of Male And Female Having Symptoms in Different Scenarios"""

sex = heart[heart['HeartDisease'] == 1]['Sex'].value_counts()
sex = [sex[0] / sum(sex) * 100, sex[1] / sum(sex) * 100]

cp = heart[heart['HeartDisease'] == 1]['ChestPainType'].value_counts()
cp = [cp[0] / sum(cp) * 100,cp[1] / sum(cp) * 100,cp[2] / sum(cp) * 100,cp[3] / sum(cp) * 100]

fbs = heart[heart['HeartDisease'] == 1]['FastingBS'].value_counts()
fbs = [fbs[0] / sum(fbs) * 100,fbs[1] / sum(fbs) * 100]

restecg = heart[heart['HeartDisease'] == 1]['RestingECG'].value_counts()
restecg = [restecg[0] / sum(restecg) * 100,restecg[1] / sum(restecg) * 100,restecg[2] / sum(restecg) * 100]

exang = heart[heart['HeartDisease'] == 1]['ExerciseAngina'].value_counts()
exang = [exang[0] / sum(exang) * 100,exang[1] / sum(exang) * 100]

slope = heart[heart['HeartDisease'] == 1]['ST_Slope'].value_counts()
slope = [slope[0] / sum(slope) * 100,slope[1] / sum(slope) * 100,slope[2] / sum(slope) * 100]
ax,fig = plt.subplots(nrows = 4,ncols = 2,figsize = (15,15))

plt.subplot(3,2,1)
plt.pie(sex,labels = ['Male','Female'],autopct='%1.1f%%',startangle = 90,explode = (0.1,0),colors = colors,
        wedgeprops = {'edgecolor' : 'black','linewidth': 1,'antialiased' : True})
plt.title('Sex');

plt.subplot(3,2,2)
plt.pie(cp,labels = ['ASY', 'NAP', 'ATA', 'TA'],autopct='%1.1f%%',startangle = 90,explode = (0,0.1,0.1,0.1),
        wedgeprops = {'edgecolor' : 'black','linewidth': 1,'antialiased' : True})
plt.title('ChestPainType');

plt.subplot(3,2,3)
plt.pie(fbs,labels = ['FBS < 120 mg/dl','FBS > 120 mg/dl'],autopct='%1.1f%%',startangle = 90,explode = (0.1,0),colors = colors,
        wedgeprops = {'edgecolor' : 'black','linewidth': 1,'antialiased' : True})
plt.title('FastingBS');

plt.subplot(3,2,4)
plt.pie(restecg,labels = ['Normal','ST','LVH'],autopct='%1.1f%%',startangle = 90,explode = (0,0.1,0.1),
        wedgeprops = {'edgecolor' : 'black','linewidth': 1,'antialiased' : True})
plt.title('RestingECG');

plt.subplot(3,2,5)
plt.pie(exang,labels = ['Angina','No Angina'],autopct='%1.1f%%',startangle = 90,explode = (0.1,0),colors = colors,
        wedgeprops = {'edgecolor' : 'black','linewidth': 1,'antialiased' : True})
plt.title('ExerciseAngina');

plt.subplot(3,2,6)
plt.pie(slope,labels = ['Flat','Up','Down'],autopct='%1.1f%%',startangle = 90,explode = (0,0.1,0.1),
        wedgeprops = {'edgecolor' : 'black','linewidth': 1,'antialiased' : True})
plt.title('ST_Slope');

"""**Step 9:** Splitting the data as training set and testing set."""

X= deep_copy_heart.iloc[:, :-1].values
Y=deep_copy_heart.iloc[:, 11].values

features = deep_copy_heart[deep_copy_heart.columns.drop(['HeartDisease','RestingBP','RestingECG'])].values
target = deep_copy_heart['HeartDisease'].values
x_train, x_test, y_train, y_test = train_test_split(features, target, test_size = 0.20, random_state = 2)

"""##Logistic Regression and testing accuracy"""

predictor= LogisticRegression()

predictor.fit(x_train, y_train)

#accuracy of train data
predict_train=predictor.predict(x_train)
training_accuracy = accuracy_score(predict_train,y_train)

print('Accuracy on the training data is: ', training_accuracy)

predict_test=predictor.predict(x_test)
testing_accuracy = accuracy_score(predict_test,y_test)

cm = confusion_matrix(y_test,predictor.predict(x_test))
names = ['True Neg','False Pos','False Neg','True Pos']
counts = [value for value in cm.flatten()]
percentages = ['{0:.2%}'.format(value) for value in cm.flatten()/np.sum(cm)]
labels = [f'{v1}\n{v2}\n{v3}' for v1, v2, v3 in zip(names,counts,percentages)]
labels = np.asarray(labels).reshape(2,2)
sns.heatmap(cm,annot = labels,cmap = colors,fmt ='')

print('Accuracy on the testing data is: ', testing_accuracy)